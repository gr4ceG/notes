# Observer Pattern
## Publish - Subscribe Model
- One class: publisher/subject - generates data
- One or more: Subscriber/observer classes - recieves data and react to it

Example: publisher spreadsheet cells, observers are graphs or formula cells, when the cells change, the graph/formulas cells update themselves

There can be many different types of observer classes, and the subject should not need to know all the details about them

Observer Pattern: 

...(6)

The abstract class subject contains all the code commmon to alll subjects - the abstract observer contains the interface common to all observers 

*Sequence of method calls:*
1. Subject's state is changed
2. `Subject::notifyObservers` is called, (either by the concrete subject when the change happens, or by the client when they change the subject)
3. `notfyObservers` call `notify` on each observer
4. Each `ConcreteObserver::notify` gets the data from their subject (e.g with `getState`) and react accordingly

*Example:* Horse races. The subject publishes the winner, the observes are individual bettors who react to winning or losing.

```c++
class Subject {
    vector<observer *> observers;
    public:
        Subject(){}
        void attach(Observer *ob){ observes.emplace_back(ob); }
        // assume each pointer shows up only once in our vector
        void detach(Observer* ob) {
            auto it = Observers.begin();
            for (it; it != Observers.end() && *it != ob; ++it) {
                if (it==observers.end()) return;
                Observers.erase(it);
            }
        }
        void notifyObservers() {
            for (auto p: Observers) p->notify();
        }
        virtual ~Subject() = o;
}; 

Subject::~Subject(){}
```

If you want a class to be abstract, but don't natrually have a method to makr pure virtual, make the destructor pure virtual (since it should always be virtual if you have inheritance). However, the destructor still needs an implementation or your code won't link.

```c++
class Observer {
    public: 
        virtual void notify() = 0;
        virtual ~observer(){}
}; 

class HorseRace : public Subject {
    ifstream in; // source of data
    String lastWinner;
    public:
        HorseRace(const String &source) : in{source}{}
        ~HorseRace(){}
        bool runRace() {
            bool b = in >> lastWinner;
            notifyObservers();
            return b;
        }
        String getState() const { return lastWinner; }
};
```
