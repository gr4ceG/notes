# Observer Pattern
## Publish - Subscribe Model
- One class: publisher/subject - generates data
- One or more: Subscriber/observer classes - recieves data and react to it

Example: publisher spreadsheet cells, observers are graphs or formula cells, when the cells change, the graph/formulas cells update themselves

There can be many different types of observer classes, and the subject should not need to know all the details about them

Observer Pattern: 

...(6)

The abstract class subject contains all the code commmon to alll subjects - the abstract observer contains the interface common to all observers 

*Sequence of method calls:*
1. Subject's state is changed
2. `Subject::notifyObservers` is called, (either by the concrete subject when the change happens, or by the client when they change the subject)
3. `notfyObservers` call `notify` on each observer
4. Each `ConcreteObserver::notify` gets the data from their subject (e.g with `getState`) and react accordingly

*Example:* Horse races. The subject publishes the winner, the observes are individual bettors who react to winning or losing.

```c++
class Subject {
    vector<observer *> observers;
    public:
        Subject(){}
        void attach(Observer *ob){ observes.emplace_back(ob); }
        // assume each pointer shows up only once in our vector
        void detach(Observer* ob) {
            auto it = Observers.begin();
            for (it; it != Observers.end() && *it != ob; ++it) {
                if (it==observers.end()) return;
                Observers.erase(it);
            }
        }
        void notifyObservers() {
            for (auto p: Observers) p->notify();
        }
        virtual ~Subject() = o;
};
```
