...

Shared pointers maintain a reference count, count of all shared pointers pointing at the same object, the memory is freed when the reference count reaches 0.

```c++
{
    int *p = new int{5};
    shared_ptr<int> spr{p};
    if (...) {
        shared_ptr<int> sp2{p};
    }
} // double free
```

Use the pointer type that accurately reflects the ownership role. Dramatically fewer opportunities for leaks this way.

There are three levels of exception safety for some function f:
1. **Basic guarentee:** if this function throws or propogates an exception, the program will be in a valid, but unspecified state. Nothing is leaked, class invariants are maintained
2. **Strong Guarentee**: if this function throws or propogates an exception, the program will be as if the function was never called
3. **No-throw Guarentee**: this function wil never throw an exception and will always complete its task

```c++
class A{...}; // A::g offers strong guarentee
class B{...}; // B::h offers strong guarentee

class C{
    A a;
    B b;
    public :
        void f() {
            a.g();
            b.h();
        }
}
```

Is `c::f` exception safe? At best, it offers the basic guarentee: 
1. if `a.g()` throws, nothing happened yet, so okay.
2. if `b.g()` throws, the effects of `a.g()` must be undone to offer the strong guarentee, very hard or impossible if `a.g()` has non-local side effects.

If `A::g` and `B::h` do not have non-local side effects, we can use the copy-swap idiom.

```c++
class C {
    A a; B b;
    public:
        A atemp{a};
        B btemp{b};

        // if either of these throw, 
        atemp.g();
        btemp.h(); 
}
```
