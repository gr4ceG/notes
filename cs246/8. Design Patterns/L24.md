Consider the `Xwindow` class. 
```c++
class Xwindow {
    Display *d;
    Window w;
    int s;
    GC gc;
    unsigned long colours[10];
    ...
};
```

What if we add or change a private member? All client code must recompile. Would be better to hide these details away.

Solution - use the pointer to implementation (pImpl) idiom.

```c++
// windowImpl.h
#include <x11/xlib.h>
struct XwindowImpl {
    Display *d;
    Window w;
    int s;
    Gc gc;
    unsigned long colours[10];
};

// window.h
class XWindowImpl; // only need to FORWARD DECLARE

class XWindow {
    XwindowImpl *p;
    public:
        ... // no change
}

// window.cc
#include "window.h"
#include "windowImpl.h"
XWindow::xwindow(...): p{new XWindowImple{...}}{}
```

All other methods just change field accesses from `d, w, s, etc.` to `p->d, p->w, p->s, etc.`

If you confine all private fields within an implementation struct, then your actual class never needs to change size and change to the private data mean only your class, not client code needs to recompile.

# Measures of Design Quality

## Coupling and Cohesion
***Coupling***: how much distinct program modules depend on each other
- (low): modules communicate via function calls with basic params and results
- modules pass arrays/structs backa and forth
- modules affect each others control flow
- modules share global data
- (high): modules have access to each other's implementation (`friend`s) 

*High coupling*:
- changes to one modules require greater changes to coupled modules
- harder to reuse individual modules

***Cohesion***: how closely elements of a module are related to one another (how focused are your modules)
- (low) arbitraty grouping of unrelated elements (e.g `<utility>`)
- elements share a common theme, otherwise unrelated, share some base code (e.g `<algorithm>`)
- 